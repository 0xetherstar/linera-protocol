// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Types for the exported futures for the contract endpoints.
//!
//! Each type is called by the code generated by [`wit_bindgen_rust`] when the host calls the guest
//! WASM module's respective endpoint. This module contains the code to forward the call to the
//! contract type that implements [`linera_sdk::Contract`].

use super::super::ApplicationState;
use linera_sdk::contract::{self, exported_futures};
use wit_bindgen_guest_rust::Handle;

pub struct Initialize(exported_futures::Initialize<ApplicationState>);

impl contract::Initialize for Initialize {
    fn new(context: contract::OperationContext, argument: Vec<u8>) -> Handle<Self> {
        Handle::new(Initialize(exported_futures::Initialize::new(
            context, argument,
        )))
    }

    fn poll(&self) -> contract::PollExecutionResult {
        self.0.poll()
    }
}

pub struct ExecuteOperation(exported_futures::ExecuteOperation<ApplicationState>);

impl contract::ExecuteOperation for ExecuteOperation {
    fn new(context: contract::OperationContext, operation: Vec<u8>) -> Handle<Self> {
        Handle::new(ExecuteOperation(exported_futures::ExecuteOperation::new(
            context, operation,
        )))
    }

    fn poll(&self) -> contract::PollExecutionResult {
        self.0.poll()
    }
}

pub struct ExecuteEffect(exported_futures::ExecuteEffect<ApplicationState>);

impl contract::ExecuteEffect for ExecuteEffect {
    fn new(context: contract::EffectContext, effect: Vec<u8>) -> Handle<Self> {
        Handle::new(ExecuteEffect(exported_futures::ExecuteEffect::new(
            context, effect,
        )))
    }

    fn poll(&self) -> contract::PollExecutionResult {
        self.0.poll()
    }
}

pub struct CallApplication(exported_futures::CallApplication<ApplicationState>);

impl contract::CallApplication for CallApplication {
    fn new(
        context: contract::CalleeContext,
        argument: Vec<u8>,
        forwarded_sessions: Vec<contract::SessionId>,
    ) -> Handle<Self> {
        Handle::new(CallApplication(exported_futures::CallApplication::new(
            context,
            argument,
            forwarded_sessions,
        )))
    }

    fn poll(&self) -> contract::PollCallApplication {
        self.0.poll()
    }
}

pub struct CallSession(exported_futures::CallSession<ApplicationState>);

impl contract::CallSession for CallSession {
    fn new(
        context: contract::CalleeContext,
        session: contract::Session,
        argument: Vec<u8>,
        forwarded_sessions: Vec<contract::SessionId>,
    ) -> Handle<Self> {
        Handle::new(CallSession(exported_futures::CallSession::new(
            context,
            session,
            argument,
            forwarded_sessions,
        )))
    }

    fn poll(&self) -> contract::PollCallSession {
        self.0.poll()
    }
}
